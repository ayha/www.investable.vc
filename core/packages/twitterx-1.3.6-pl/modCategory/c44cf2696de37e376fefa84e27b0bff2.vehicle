<?php return array (
  'unique_key' => 'category',
  'preserve_keys' => false,
  'update_object' => true,
  'related_objects' => 
  array (
    'Chunks' => 
    array (
      'b7cbf6126889b01f27fbc2a09b85dbca' => 
      array (
        'preserve_keys' => false,
        'update_object' => true,
        'unique_key' => 'name',
        'class' => 'modChunk',
        'object' => '{"id":47,"source":0,"property_preprocess":0,"name":"TwitterXTpl","description":"TwitterX tweet chunk - duplicate this and edit as upgrading TwitterX will overwrite your changes","editor_type":0,"category":33,"cache_type":0,"snippet":"<li>\\n  <p class=\\"status\\">[[+text:TwitterXFormat]]<\\/p>\\n  <p class=\\"status-info\\"><a href=\\"http:\\/\\/twitter.com\\/[[+screen_name]]\\" target=\\"_blank\\"><img src=\\"[[+profile_image_url]]\\" alt=\\"[[+name]] on Twitter\\" \\/>[[+name]]<\\/a> <span>[[+created_at:ago]]<\\/span><\\/p>\\n<\\/li>","locked":0,"properties":"a:0:{}","static":0,"static_file":"","content":"<li>\\n  <p class=\\"status\\">[[+text:TwitterXFormat]]<\\/p>\\n  <p class=\\"status-info\\"><a href=\\"http:\\/\\/twitter.com\\/[[+screen_name]]\\" target=\\"_blank\\"><img src=\\"[[+profile_image_url]]\\" alt=\\"[[+name]] on Twitter\\" \\/>[[+name]]<\\/a> <span>[[+created_at:ago]]<\\/span><\\/p>\\n<\\/li>"}',
        'guid' => '8b91ebf179ba13818b3a46a9a42bdefa',
        'native_key' => 47,
        'signature' => 'be86c54651f74df8ca7434ca64ff374b',
      ),
    ),
    'Snippets' => 
    array (
      '09e8d543c952f1507f4edd54fa1cfec3' => 
      array (
        'preserve_keys' => false,
        'update_object' => true,
        'unique_key' => 'name',
        'class' => 'modSnippet',
        'object' => '{"id":52,"source":0,"property_preprocess":0,"name":"TwitterX","description":"This package loads Twitter feeds using the new (and very annoying) Twitter 1.1 API.","editor_type":0,"category":33,"cache_type":0,"snippet":"\\/**\\n * TwitterX\\n *\\n * This package loads Twitter feeds using the new (and very annoying) Twitter\\n * 1.1 API. You will need to create a Twitter app and get the keys and tokens\\n * by creating a new app here: https:\\/\\/dev.twitter.com\\/apps\\/new\\n *\\n * This uses twitteroauth: https:\\/\\/github.com\\/abraham\\/twitteroauth\\n *\\n * TwitterX is free software; you can redistribute it and\\/or modify it\\n * under the terms of the GNU General Public License as published by the Free\\n * Software Foundation; either version 2 of the License, or (at your option) any\\n * later version.\\n *\\n * TwitterX is distributed in the hope that it will be useful, but WITHOUT ANY\\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\\n * A PARTICULAR PURPOSE. See the GNU General Public License for more details.\\n\\n * @author Stewart Orr @ Qodo Ltd <stewart@qodo.co.uk>\\n * @version 1.3.6\\n * @copyright Copyright Qodo Ltd 2014\\n * With thanks to @Sepiariver http:\\/\\/www.sepiariver.ca\\/\\n * With thanks to @hvoort\\n * With thanks to @OostDesign\\n * With thanks to Dameon87 https:\\/\\/github.com\\/Dameon87\\n *\\/\\n\\n\\/\\/ Twitter API keys and secrets\\n$twitter_consumer_key          = isset($twitter_consumer_key) ? $twitter_consumer_key : FALSE ;\\n$twitter_consumer_secret       = isset($twitter_consumer_secret) ? $twitter_consumer_secret : FALSE ;\\n$twitter_access_token          = isset($twitter_access_token) ? $twitter_access_token : FALSE ;\\n$twitter_access_token_secret   = isset($twitter_access_token_secret) ? $twitter_access_token_secret : FALSE ;\\n\\n\\/\\/ Other options\\n$limit = isset($limit) ? $limit : 5 ;\\n$chunk = isset($chunk) ? $chunk : \'TwitterXTpl\' ;\\n$timeline = isset($timeline) ? $timeline : \'user_timeline\' ;\\n$cache = isset($cache) ? $cache : 7200 ;\\n$screen_name = isset($screen_name ) ? $screen_name : \'\' ;\\n$include_rts = isset($include_rts) ? $include_rts : 1 ;\\n$exclude_replies  = isset($exclude_replies) ? $exclude_replies : 0 ;\\n$cache_id = isset($cache_id) ? $cache_id : \'TwitterX_\' .  $modx->resource->id ;\\n$toPlaceholder = isset($toPlaceholder) ? $toPlaceholder : \'\' ;\\n$toPlaceholderPrefix = isset($toPlaceholderPrefix) ? $toPlaceholderPrefix . \\".\\" : \'\' ; \\/\\/ If you want to prefix the placeholders\\n$search = isset($search) ? $search : \'\' ;\\n$slug = isset($slug) ? $slug : \'\' ; \\/\\/ Slug is only used when viewing a list\\n\\n\\/\\/ Here we support an old error where the parameter was incorrect.\\nif (isset($twitter_consumer_token_secret)) {\\n\\t$twitter_access_token_secret = isset($twitter_consumer_token_secret) ? $twitter_consumer_token_secret : FALSE ;\\n}\\n\\n\\/\\/ Function to compare tweets based on their creation time\\nif (!function_exists(\'compareTweetsByDate\')) {\\n\\tfunction compareTweetsByDate($a, $b) {\\n\\t\\t$time_a = strtotime($a->created_at);\\n\\t\\t$time_b = strtotime($b->created_at);\\n\\n\\t\\tif ($time_a == $time_b) {\\n\\t\\t  return 0;\\n\\t\\t}\\n\\t\\treturn ($time_a > $time_b) ? -1 : 1;\\n\\t}\\n}\\n\\n\\/\\/ Simple function to for use with array_map for sanitizing purposes.\\nif (!function_exists(\'sanitize_array\')) {\\n\\tfunction sanitize_array($input) {\\n\\t\\treturn htmlentities($input, ENT_QUOTES, \'UTF-8\', false);\\n\\t}\\n}\\n\\n\\/\\/ HTML output \\n$output = \'\';\\n\\n\\/\\/**************************************************************************\\n\\n\\/\\/ If they haven\'t specified the required Twitter keys, we cannot continue...\\nif (!$twitter_consumer_key || !$twitter_consumer_secret || !$twitter_access_token || !$twitter_access_token_secret) {\\n\\n\\techo \\"<strong>TwitterX Error:<\\/strong> Could not load TwitterX as required values were not passed.\\";\\n\\n} else {\\n\\n\\t\\/\\/ Test for required function(s)\\n\\tif (!function_exists(\'curl_init\')) {\\n\\t\\t\\n\\t\\t\\techo \\"<strong>TwitterX Error:<\\/strong> cURL functions do not exist, cannot continue.\\";\\t\\n\\t\\t\\t\\n\\t} else {\\n\\n\\t\\t\\/\\/ Try loading the data from MODX cache first\\n\\t\\t$json = $modx->cacheManager->get($cache_id); \\/\\/ Added ability to set custom cache IDs\\n\\t\\t\\n\\t\\tif (!$json) { \\n\\n\\t\\t\\t\\/\\/ Load the TwitterOAuth lib required if not exists\\n\\t\\t\\tif (!class_exists(\'TwitterOAuth\')) {\\n\\t\\t\\t\\trequire_once $modx->getOption(\'core_path\').\'components\\/twitterx\\/twitteroauth\\/twitteroauth\\/twitteroauth.php\';\\n\\t\\t\\t}\\n\\t\\t\\t\\/\\/ Create new twitteroauth\\n\\t\\t\\t$twitteroauth = new TwitterOAuth($twitter_consumer_key, $twitter_consumer_secret, $twitter_access_token, $twitter_access_token_secret);\\n\\n\\t\\t\\t\\/\\/ We want to use JSON format\\n\\t\\t\\t$twitteroauth->format = \'json\';\\n\\t\\t\\t$twitteroauth->decode_json = FALSE;\\n\\n\\t\\t\\t\\/\\/ If we are doing a search, we use the search timeline\\n\\t\\t\\tif ($search != \'\') {\\n\\n\\t\\t\\t\\t$timeline = \'search\\/tweets\';\\n\\t\\t\\t\\t$options = array(\\n\\t\\t\\t\\t\\t\'count\' => 150, \\/\\/ This is large number because of the way twitter excludes retweets and replies\\n\\t\\t\\t\\t\\t\'q\' => $search,\\n\\t\\t\\t\\t);\\n\\t\\t\\t\\t$json = $twitteroauth->get($timeline, $options);\\n\\t\\t                \\n                \\/\\/ Because search returns info on the search, we need to decode, get the results and then encode again\\n    \\t\\t\\t\\/\\/ This is so we can cache this too. Messy but it works!\\n\\t\\t\\t\\t$json = json_decode($json);\\n\\t\\t\\t\\t$json = $json->statuses;\\n\\t\\t\\t\\t$json = json_encode($json);\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\/\\/ Request statuses with optional parameters\\n\\t\\t\\t\\t$options = array(\\n\\t\\t\\t\\t\\t\'count\' => 150, \\/\\/ This is large number because of the way twitter excludes retweets and replies\\n\\t\\t\\t\\t\\t\'include_rts\' => $include_rts,\\n\\t\\t\\t\\t\\t\'exclude_replies\' => $exclude_replies,\\n\\t\\t\\t\\t);\\n\\n\\t\\t\\t\\t\\/\\/ If we are viewing favourites or regular statuses\\n\\t\\t\\t\\tif ($timeline != \'favorites\' && $timeline != \'lists\\/statuses\') {\\n\\t\\t\\t\\t\\t$timeline = \'statuses\\/\' . $timeline;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\/\\/ Favourites - thanks to @sepiariver\\n\\t\\t\\t\\tif ($timeline === \'favorites\') { $timeline = $timeline . \'\\/list\'; }\\n\\n\\n\\t\\t\\t\\t\\/\\/ If we have one or multiple screen names\\n\\t\\t\\t\\tif (strpos($screen_name, \',\') !== FALSE) {\\n\\n\\t\\t\\t\\t\\t$tweets = array();\\n\\n\\t\\t\\t\\t\\t\\/\\/ Collect screen_names\\n\\t\\t\\t\\t\\t$screen_name_array = preg_split(\\"\\/,\\/\\", $screen_name, -1, PREG_SPLIT_NO_EMPTY);\\n\\n\\t\\t\\t\\t\\tif (count($screen_name_array) >= 1) {\\n\\t\\t\\t\\t\\t\\t\\/\\/ Get timeline for every screen name\\n\\t\\t\\t\\t\\t\\tforeach ($screen_name_array as $sn) {\\n\\t\\t\\t\\t\\t\\t\\t$options[\'screen_name\'] = $sn;\\n\\t\\t\\t\\t\\t\\t\\t$json_part = $twitteroauth->get($timeline, $options);\\n\\n\\t\\t\\t\\t\\t\\t\\t\\/\\/ No error while loading timeline\\n\\t\\t\\t\\t\\t\\t\\tif (!isset($json_part->error)) {\\n\\t\\t\\t\\t\\t\\t\\t\\t$tweets = array_merge($tweets, json_decode($json_part));\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\/\\/ Sort mixed tweets of different users\\n\\t\\t\\t\\t\\tusort($tweets, \'compareTweetsByDate\');\\n\\n\\t\\t\\t\\t\\t\\/\\/ Limit the combined result\\n\\t\\t\\t\\t\\t$tweets = array_slice($tweets, 0, $limit);\\n\\n\\t\\t\\t\\t\\t\\/\\/ Convert array to json for saving to cache\\n\\t\\t\\t\\t\\t$json = json_encode($tweets);\\n\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\/\\/ Here we are looking to see if we want a list instead of timeline\\n\\t\\t\\t\\t\\tif ($slug != \'\') {\\n\\t\\t\\t\\t\\t\\t$options[\'owner_screen_name\'] = $screen_name;\\n\\t\\t\\t\\t\\t\\t$options[\'slug\'] = $slug;\\n\\t\\t\\t\\t\\t} elseif ($screen_name != \'\') {\\n\\t\\t\\t\\t\\t\\t\\/\\/ If we have a single screen_name, pass this to Twitter API\\n\\t\\t\\t\\t\\t\\t$options[\'screen_name\'] = $screen_name;\\t\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t$json = $twitteroauth->get($timeline, $options);\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t\\/\\/ No errors? Save to MODX Cache\\n\\t\\t\\tif (!isset($json->error)) {\\n\\t\\t\\t\\t$modx->cacheManager->set($cache_id, $json, $cache);\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\t\\/\\/ Decode this now that we have used it above in the cache\\n\\t\\t$json = json_decode($json);\\n\\n\\t\\t\\/\\/ If there any errors from Twitter, output them...\\n\\t\\tif (isset($json->errors)) {\\n\\n\\t\\t\\tforeach($json->errors as $err) {\\n\\t\\t\\t\\t$output .= \\"<strong>TwitterX Error:<\\/strong> Could not load tweets as Twitter responded with the error: \'\\" . $err->message . \\"\'.\\";\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\n\\t\\t} else {\\n\\n\\t\\t\\t\\/\\/ Any tweets present?\\n\\t\\t\\tif (is_array($json) && count($json) > 0) {\\n\\n\\t\\t\\t\\t\\/\\/ Counter for number of tweets\\n\\t\\t\\t\\t$tweetCount = 0;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\/\\/ For each result, build output values\\n\\t\\t\\t\\tforeach ($json as $j) {\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\/\\/ If we already have enough tweets, break\\n\\t\\t\\t\\t\\tif ($tweetCount >= $limit) break;\\n\\n\\t\\t\\t\\t\\t\\/\\/ Get placerholder values\\n\\t\\t\\t\\t\\t\\/\\/ This has been updated to use search values if present\\n\\t\\t\\t\\t\\t$placeholders = array(\\n\\t\\t\\t\\t\\t\\t$toPlaceholderPrefix . \'created_at\' => $j->created_at,\\n\\t\\t\\t\\t\\t\\t$toPlaceholderPrefix . \'source\' => $j->source,\\n\\t\\t\\t\\t\\t\\t$toPlaceholderPrefix . \'id\' => $j->id,\\n\\t\\t\\t\\t\\t\\t$toPlaceholderPrefix . \'id_str\' => $j->id_str,\\n\\t\\t\\t\\t\\t\\t$toPlaceholderPrefix . \'text\' => $j->text,\\n\\t\\t\\t\\t\\t\\t$toPlaceholderPrefix . \'name\' => isset($j->from_user_name) ? $j->from_user_name : $j->user->name,\\n\\t\\t\\t\\t\\t\\t$toPlaceholderPrefix . \'screen_name\' => isset($j->from_user) ? $j->from_user : $j->user->screen_name,\\n\\t\\t\\t\\t\\t\\t$toPlaceholderPrefix . \'profile_image_url\' => isset($j->profile_image_url_https) ? $j->profile_image_url_https : $j->user->profile_image_url_https,\\n\\t\\t\\t\\t\\t\\t$toPlaceholderPrefix . \'location\' => $j->user->location,\\n\\t\\t\\t\\t\\t\\t$toPlaceholderPrefix . \'url\' => $j->user->url,\\n\\t\\t\\t\\t\\t\\t$toPlaceholderPrefix . \'description\' => $j->user->description,\\n\\t\\t\\t\\t\\t);\\n\\n\\t\\t\\t\\t\\t\\/\\/ If this is a retweet, create placeholders for this too\\n\\t\\t\\t\\t\\tif (isset($j->retweeted_status)) {\\n\\t\\t\\t\\t\\t\\t$placeholders = array_merge($placeholders, array(\\n\\t\\t\\t\\t\\t\\t    \\/\\/ Here we change the text to prevent truncation\\n\\t\\t\\t\\t\\t\\t    $toPlaceholderPrefix . \'text\' => \'RT @\' . $j->retweeted_status->user->name . \': \' . $j->retweeted_status->text,\\n\\t\\t\\t\\t\\t\\t\\t$toPlaceholderPrefix . \'retweet_count\' => $j->retweeted_status->retweet_count,\\n\\t\\t\\t\\t\\t\\t\\t$toPlaceholderPrefix . \'retweet_created_at\' => $j->retweeted_status->created_at,\\n\\t\\t\\t\\t\\t\\t\\t$toPlaceholderPrefix . \'retweet_source\' => $j->retweeted_status->source,\\n\\t\\t\\t\\t\\t\\t\\t$toPlaceholderPrefix . \'retweet_id\' => $j->retweeted_status->id,\\n\\t\\t\\t\\t\\t\\t\\t$toPlaceholderPrefix . \'retweet_id_str\' => $j->retweeted_status->id_str,\\n\\t\\t\\t\\t\\t\\t\\t$toPlaceholderPrefix . \'retweet_text\' => $j->retweeted_status->text,\\n\\t\\t\\t\\t\\t\\t\\t$toPlaceholderPrefix . \'retweet_name\' => $j->retweeted_status->user->name,\\n\\t\\t\\t\\t\\t\\t\\t$toPlaceholderPrefix . \'retweet_screen_name\' => $j->retweeted_status->user->screen_name,\\n\\t\\t\\t\\t\\t\\t\\t$toPlaceholderPrefix . \'retweet_profile_image_url\' => $j->retweeted_status->user->profile_image_url_https,\\n\\t\\t\\t\\t\\t\\t\\t$toPlaceholderPrefix . \'retweet_location\' => $j->retweeted_status->user->location,\\n\\t\\t\\t\\t\\t\\t\\t$toPlaceholderPrefix . \'retweet_url\' => $j->retweeted_status->user->url,\\n\\t\\t\\t\\t\\t\\t\\t$toPlaceholderPrefix . \'retweet_description\' => $j->retweeted_status->user->description,\\n\\t\\t\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\t\\t\\t);\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\/\\/ For some added safety, lets sanitize the $placeholders variable first to ensure there isn\'t much room for potential exploit.\\n\\t\\t\\t\\t\\t$placeholders = array_map(\'sanitize_array\', $placeholders);\\n\\n\\t\\t\\t\\t\\t\\/\\/ Parse chunk passing values\\n\\t\\t\\t\\t\\t$output .= $modx->getChunk($chunk, $placeholders); \\/\\/ Concatenate to output variable\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\/\\/ Update number of tweets\\n\\t\\t\\t\\t\\t$tweetCount++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t\\/\\/ Added option to output to placeholder\\n\\t\\tif ($toPlaceholder != \'\') {\\n\\t\\t\\t$modx->setPlaceholder($toPlaceholder, $output);\\n\\t\\t} else {\\n\\t\\t\\treturn $output;\\n\\t\\t}\\n\\t}\\n}","locked":0,"properties":"a:0:{}","moduleguid":"","static":0,"static_file":"","content":"\\/**\\n * TwitterX\\n *\\n * This package loads Twitter feeds using the new (and very annoying) Twitter\\n * 1.1 API. You will need to create a Twitter app and get the keys and tokens\\n * by creating a new app here: https:\\/\\/dev.twitter.com\\/apps\\/new\\n *\\n * This uses twitteroauth: https:\\/\\/github.com\\/abraham\\/twitteroauth\\n *\\n * TwitterX is free software; you can redistribute it and\\/or modify it\\n * under the terms of the GNU General Public License as published by the Free\\n * Software Foundation; either version 2 of the License, or (at your option) any\\n * later version.\\n *\\n * TwitterX is distributed in the hope that it will be useful, but WITHOUT ANY\\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\\n * A PARTICULAR PURPOSE. See the GNU General Public License for more details.\\n\\n * @author Stewart Orr @ Qodo Ltd <stewart@qodo.co.uk>\\n * @version 1.3.6\\n * @copyright Copyright Qodo Ltd 2014\\n * With thanks to @Sepiariver http:\\/\\/www.sepiariver.ca\\/\\n * With thanks to @hvoort\\n * With thanks to @OostDesign\\n * With thanks to Dameon87 https:\\/\\/github.com\\/Dameon87\\n *\\/\\n\\n\\/\\/ Twitter API keys and secrets\\n$twitter_consumer_key          = isset($twitter_consumer_key) ? $twitter_consumer_key : FALSE ;\\n$twitter_consumer_secret       = isset($twitter_consumer_secret) ? $twitter_consumer_secret : FALSE ;\\n$twitter_access_token          = isset($twitter_access_token) ? $twitter_access_token : FALSE ;\\n$twitter_access_token_secret   = isset($twitter_access_token_secret) ? $twitter_access_token_secret : FALSE ;\\n\\n\\/\\/ Other options\\n$limit = isset($limit) ? $limit : 5 ;\\n$chunk = isset($chunk) ? $chunk : \'TwitterXTpl\' ;\\n$timeline = isset($timeline) ? $timeline : \'user_timeline\' ;\\n$cache = isset($cache) ? $cache : 7200 ;\\n$screen_name = isset($screen_name ) ? $screen_name : \'\' ;\\n$include_rts = isset($include_rts) ? $include_rts : 1 ;\\n$exclude_replies  = isset($exclude_replies) ? $exclude_replies : 0 ;\\n$cache_id = isset($cache_id) ? $cache_id : \'TwitterX_\' .  $modx->resource->id ;\\n$toPlaceholder = isset($toPlaceholder) ? $toPlaceholder : \'\' ;\\n$toPlaceholderPrefix = isset($toPlaceholderPrefix) ? $toPlaceholderPrefix . \\".\\" : \'\' ; \\/\\/ If you want to prefix the placeholders\\n$search = isset($search) ? $search : \'\' ;\\n$slug = isset($slug) ? $slug : \'\' ; \\/\\/ Slug is only used when viewing a list\\n\\n\\/\\/ Here we support an old error where the parameter was incorrect.\\nif (isset($twitter_consumer_token_secret)) {\\n\\t$twitter_access_token_secret = isset($twitter_consumer_token_secret) ? $twitter_consumer_token_secret : FALSE ;\\n}\\n\\n\\/\\/ Function to compare tweets based on their creation time\\nif (!function_exists(\'compareTweetsByDate\')) {\\n\\tfunction compareTweetsByDate($a, $b) {\\n\\t\\t$time_a = strtotime($a->created_at);\\n\\t\\t$time_b = strtotime($b->created_at);\\n\\n\\t\\tif ($time_a == $time_b) {\\n\\t\\t  return 0;\\n\\t\\t}\\n\\t\\treturn ($time_a > $time_b) ? -1 : 1;\\n\\t}\\n}\\n\\n\\/\\/ Simple function to for use with array_map for sanitizing purposes.\\nif (!function_exists(\'sanitize_array\')) {\\n\\tfunction sanitize_array($input) {\\n\\t\\treturn htmlentities($input, ENT_QUOTES, \'UTF-8\', false);\\n\\t}\\n}\\n\\n\\/\\/ HTML output \\n$output = \'\';\\n\\n\\/\\/**************************************************************************\\n\\n\\/\\/ If they haven\'t specified the required Twitter keys, we cannot continue...\\nif (!$twitter_consumer_key || !$twitter_consumer_secret || !$twitter_access_token || !$twitter_access_token_secret) {\\n\\n\\techo \\"<strong>TwitterX Error:<\\/strong> Could not load TwitterX as required values were not passed.\\";\\n\\n} else {\\n\\n\\t\\/\\/ Test for required function(s)\\n\\tif (!function_exists(\'curl_init\')) {\\n\\t\\t\\n\\t\\t\\techo \\"<strong>TwitterX Error:<\\/strong> cURL functions do not exist, cannot continue.\\";\\t\\n\\t\\t\\t\\n\\t} else {\\n\\n\\t\\t\\/\\/ Try loading the data from MODX cache first\\n\\t\\t$json = $modx->cacheManager->get($cache_id); \\/\\/ Added ability to set custom cache IDs\\n\\t\\t\\n\\t\\tif (!$json) { \\n\\n\\t\\t\\t\\/\\/ Load the TwitterOAuth lib required if not exists\\n\\t\\t\\tif (!class_exists(\'TwitterOAuth\')) {\\n\\t\\t\\t\\trequire_once $modx->getOption(\'core_path\').\'components\\/twitterx\\/twitteroauth\\/twitteroauth\\/twitteroauth.php\';\\n\\t\\t\\t}\\n\\t\\t\\t\\/\\/ Create new twitteroauth\\n\\t\\t\\t$twitteroauth = new TwitterOAuth($twitter_consumer_key, $twitter_consumer_secret, $twitter_access_token, $twitter_access_token_secret);\\n\\n\\t\\t\\t\\/\\/ We want to use JSON format\\n\\t\\t\\t$twitteroauth->format = \'json\';\\n\\t\\t\\t$twitteroauth->decode_json = FALSE;\\n\\n\\t\\t\\t\\/\\/ If we are doing a search, we use the search timeline\\n\\t\\t\\tif ($search != \'\') {\\n\\n\\t\\t\\t\\t$timeline = \'search\\/tweets\';\\n\\t\\t\\t\\t$options = array(\\n\\t\\t\\t\\t\\t\'count\' => 150, \\/\\/ This is large number because of the way twitter excludes retweets and replies\\n\\t\\t\\t\\t\\t\'q\' => $search,\\n\\t\\t\\t\\t);\\n\\t\\t\\t\\t$json = $twitteroauth->get($timeline, $options);\\n\\t\\t                \\n                \\/\\/ Because search returns info on the search, we need to decode, get the results and then encode again\\n    \\t\\t\\t\\/\\/ This is so we can cache this too. Messy but it works!\\n\\t\\t\\t\\t$json = json_decode($json);\\n\\t\\t\\t\\t$json = $json->statuses;\\n\\t\\t\\t\\t$json = json_encode($json);\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\/\\/ Request statuses with optional parameters\\n\\t\\t\\t\\t$options = array(\\n\\t\\t\\t\\t\\t\'count\' => 150, \\/\\/ This is large number because of the way twitter excludes retweets and replies\\n\\t\\t\\t\\t\\t\'include_rts\' => $include_rts,\\n\\t\\t\\t\\t\\t\'exclude_replies\' => $exclude_replies,\\n\\t\\t\\t\\t);\\n\\n\\t\\t\\t\\t\\/\\/ If we are viewing favourites or regular statuses\\n\\t\\t\\t\\tif ($timeline != \'favorites\' && $timeline != \'lists\\/statuses\') {\\n\\t\\t\\t\\t\\t$timeline = \'statuses\\/\' . $timeline;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\/\\/ Favourites - thanks to @sepiariver\\n\\t\\t\\t\\tif ($timeline === \'favorites\') { $timeline = $timeline . \'\\/list\'; }\\n\\n\\n\\t\\t\\t\\t\\/\\/ If we have one or multiple screen names\\n\\t\\t\\t\\tif (strpos($screen_name, \',\') !== FALSE) {\\n\\n\\t\\t\\t\\t\\t$tweets = array();\\n\\n\\t\\t\\t\\t\\t\\/\\/ Collect screen_names\\n\\t\\t\\t\\t\\t$screen_name_array = preg_split(\\"\\/,\\/\\", $screen_name, -1, PREG_SPLIT_NO_EMPTY);\\n\\n\\t\\t\\t\\t\\tif (count($screen_name_array) >= 1) {\\n\\t\\t\\t\\t\\t\\t\\/\\/ Get timeline for every screen name\\n\\t\\t\\t\\t\\t\\tforeach ($screen_name_array as $sn) {\\n\\t\\t\\t\\t\\t\\t\\t$options[\'screen_name\'] = $sn;\\n\\t\\t\\t\\t\\t\\t\\t$json_part = $twitteroauth->get($timeline, $options);\\n\\n\\t\\t\\t\\t\\t\\t\\t\\/\\/ No error while loading timeline\\n\\t\\t\\t\\t\\t\\t\\tif (!isset($json_part->error)) {\\n\\t\\t\\t\\t\\t\\t\\t\\t$tweets = array_merge($tweets, json_decode($json_part));\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\/\\/ Sort mixed tweets of different users\\n\\t\\t\\t\\t\\tusort($tweets, \'compareTweetsByDate\');\\n\\n\\t\\t\\t\\t\\t\\/\\/ Limit the combined result\\n\\t\\t\\t\\t\\t$tweets = array_slice($tweets, 0, $limit);\\n\\n\\t\\t\\t\\t\\t\\/\\/ Convert array to json for saving to cache\\n\\t\\t\\t\\t\\t$json = json_encode($tweets);\\n\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\/\\/ Here we are looking to see if we want a list instead of timeline\\n\\t\\t\\t\\t\\tif ($slug != \'\') {\\n\\t\\t\\t\\t\\t\\t$options[\'owner_screen_name\'] = $screen_name;\\n\\t\\t\\t\\t\\t\\t$options[\'slug\'] = $slug;\\n\\t\\t\\t\\t\\t} elseif ($screen_name != \'\') {\\n\\t\\t\\t\\t\\t\\t\\/\\/ If we have a single screen_name, pass this to Twitter API\\n\\t\\t\\t\\t\\t\\t$options[\'screen_name\'] = $screen_name;\\t\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t$json = $twitteroauth->get($timeline, $options);\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t\\/\\/ No errors? Save to MODX Cache\\n\\t\\t\\tif (!isset($json->error)) {\\n\\t\\t\\t\\t$modx->cacheManager->set($cache_id, $json, $cache);\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\t\\/\\/ Decode this now that we have used it above in the cache\\n\\t\\t$json = json_decode($json);\\n\\n\\t\\t\\/\\/ If there any errors from Twitter, output them...\\n\\t\\tif (isset($json->errors)) {\\n\\n\\t\\t\\tforeach($json->errors as $err) {\\n\\t\\t\\t\\t$output .= \\"<strong>TwitterX Error:<\\/strong> Could not load tweets as Twitter responded with the error: \'\\" . $err->message . \\"\'.\\";\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\n\\t\\t} else {\\n\\n\\t\\t\\t\\/\\/ Any tweets present?\\n\\t\\t\\tif (is_array($json) && count($json) > 0) {\\n\\n\\t\\t\\t\\t\\/\\/ Counter for number of tweets\\n\\t\\t\\t\\t$tweetCount = 0;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\/\\/ For each result, build output values\\n\\t\\t\\t\\tforeach ($json as $j) {\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\/\\/ If we already have enough tweets, break\\n\\t\\t\\t\\t\\tif ($tweetCount >= $limit) break;\\n\\n\\t\\t\\t\\t\\t\\/\\/ Get placerholder values\\n\\t\\t\\t\\t\\t\\/\\/ This has been updated to use search values if present\\n\\t\\t\\t\\t\\t$placeholders = array(\\n\\t\\t\\t\\t\\t\\t$toPlaceholderPrefix . \'created_at\' => $j->created_at,\\n\\t\\t\\t\\t\\t\\t$toPlaceholderPrefix . \'source\' => $j->source,\\n\\t\\t\\t\\t\\t\\t$toPlaceholderPrefix . \'id\' => $j->id,\\n\\t\\t\\t\\t\\t\\t$toPlaceholderPrefix . \'id_str\' => $j->id_str,\\n\\t\\t\\t\\t\\t\\t$toPlaceholderPrefix . \'text\' => $j->text,\\n\\t\\t\\t\\t\\t\\t$toPlaceholderPrefix . \'name\' => isset($j->from_user_name) ? $j->from_user_name : $j->user->name,\\n\\t\\t\\t\\t\\t\\t$toPlaceholderPrefix . \'screen_name\' => isset($j->from_user) ? $j->from_user : $j->user->screen_name,\\n\\t\\t\\t\\t\\t\\t$toPlaceholderPrefix . \'profile_image_url\' => isset($j->profile_image_url_https) ? $j->profile_image_url_https : $j->user->profile_image_url_https,\\n\\t\\t\\t\\t\\t\\t$toPlaceholderPrefix . \'location\' => $j->user->location,\\n\\t\\t\\t\\t\\t\\t$toPlaceholderPrefix . \'url\' => $j->user->url,\\n\\t\\t\\t\\t\\t\\t$toPlaceholderPrefix . \'description\' => $j->user->description,\\n\\t\\t\\t\\t\\t);\\n\\n\\t\\t\\t\\t\\t\\/\\/ If this is a retweet, create placeholders for this too\\n\\t\\t\\t\\t\\tif (isset($j->retweeted_status)) {\\n\\t\\t\\t\\t\\t\\t$placeholders = array_merge($placeholders, array(\\n\\t\\t\\t\\t\\t\\t    \\/\\/ Here we change the text to prevent truncation\\n\\t\\t\\t\\t\\t\\t    $toPlaceholderPrefix . \'text\' => \'RT @\' . $j->retweeted_status->user->name . \': \' . $j->retweeted_status->text,\\n\\t\\t\\t\\t\\t\\t\\t$toPlaceholderPrefix . \'retweet_count\' => $j->retweeted_status->retweet_count,\\n\\t\\t\\t\\t\\t\\t\\t$toPlaceholderPrefix . \'retweet_created_at\' => $j->retweeted_status->created_at,\\n\\t\\t\\t\\t\\t\\t\\t$toPlaceholderPrefix . \'retweet_source\' => $j->retweeted_status->source,\\n\\t\\t\\t\\t\\t\\t\\t$toPlaceholderPrefix . \'retweet_id\' => $j->retweeted_status->id,\\n\\t\\t\\t\\t\\t\\t\\t$toPlaceholderPrefix . \'retweet_id_str\' => $j->retweeted_status->id_str,\\n\\t\\t\\t\\t\\t\\t\\t$toPlaceholderPrefix . \'retweet_text\' => $j->retweeted_status->text,\\n\\t\\t\\t\\t\\t\\t\\t$toPlaceholderPrefix . \'retweet_name\' => $j->retweeted_status->user->name,\\n\\t\\t\\t\\t\\t\\t\\t$toPlaceholderPrefix . \'retweet_screen_name\' => $j->retweeted_status->user->screen_name,\\n\\t\\t\\t\\t\\t\\t\\t$toPlaceholderPrefix . \'retweet_profile_image_url\' => $j->retweeted_status->user->profile_image_url_https,\\n\\t\\t\\t\\t\\t\\t\\t$toPlaceholderPrefix . \'retweet_location\' => $j->retweeted_status->user->location,\\n\\t\\t\\t\\t\\t\\t\\t$toPlaceholderPrefix . \'retweet_url\' => $j->retweeted_status->user->url,\\n\\t\\t\\t\\t\\t\\t\\t$toPlaceholderPrefix . \'retweet_description\' => $j->retweeted_status->user->description,\\n\\t\\t\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\t\\t\\t);\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\/\\/ For some added safety, lets sanitize the $placeholders variable first to ensure there isn\'t much room for potential exploit.\\n\\t\\t\\t\\t\\t$placeholders = array_map(\'sanitize_array\', $placeholders);\\n\\n\\t\\t\\t\\t\\t\\/\\/ Parse chunk passing values\\n\\t\\t\\t\\t\\t$output .= $modx->getChunk($chunk, $placeholders); \\/\\/ Concatenate to output variable\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\/\\/ Update number of tweets\\n\\t\\t\\t\\t\\t$tweetCount++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t\\/\\/ Added option to output to placeholder\\n\\t\\tif ($toPlaceholder != \'\') {\\n\\t\\t\\t$modx->setPlaceholder($toPlaceholder, $output);\\n\\t\\t} else {\\n\\t\\t\\treturn $output;\\n\\t\\t}\\n\\t}\\n}"}',
        'guid' => '812e41b8d893f42866bdd8b3f842b23d',
        'native_key' => 52,
        'signature' => '5ca69be7dc5f7ff0f2abea6508d65402',
      ),
      '4ab6eaa58dd01ed7d9bc0b4703c47f19' => 
      array (
        'preserve_keys' => false,
        'update_object' => true,
        'unique_key' => 'name',
        'class' => 'modSnippet',
        'object' => '{"id":53,"source":0,"property_preprocess":0,"name":"TwitterXFormat","description":"This snippet simply formats and links twitter feed statuses.","editor_type":0,"category":33,"cache_type":0,"snippet":"\\/**\\n * TwitterXFormat\\n *\\n * This snippet simply formats and links twitter feed statuses.\\n *\\n * TwitterX is free software; you can redistribute it and\\/or modify it\\n * under the terms of the GNU General Public License as published by the Free\\n * Software Foundation; either version 2 of the License, or (at your option) any\\n * later version.\\n *\\n * TwitterX is distributed in the hope that it will be useful, but WITHOUT ANY\\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\\n * A PARTICULAR PURPOSE. See the GNU General Public License for more details.\\n\\n * @author Stewart Orr @ Qodo Ltd <stewart@qodo.co.uk>\\n * @version 1.3.6\\n * @copyright Copyright 2012 by Qodo Ltd\\n * With thanks to Dameon87 https:\\/\\/github.com\\/Dameon87\\n *\\/\\n\\n$output = preg_replace(\'\\/(https?:\\\\\\/\\\\\\/[^\\\\s\\"<>]+)\\/\',\'<a href=\\"$1\\" target=\\"_blank\\" rel=\\"nofollow\\">$1<\\/a>\', $input);\\n$output = preg_replace(\'\\/(^|[\\\\n\\\\s])#([^\\\\s\\"\\\\t\\\\n\\\\r<:]*)\\/is\', \'$1<a href=\\"https:\\/\\/twitter.com\\/search?q=%23$2\\" target=\\"_blank\\" rel=\\"nofollow\\">#$2<\\/a>\', $output);\\n$output = preg_replace(\'\\/(^|[\\\\n\\\\s])@([^\\\\s\\"\\\\t\\\\n\\\\r<:]*)\\/is\', \'$1<a href=\\"https:\\/\\/twitter.com\\/$2\\" target=\\"_blank\\" rel=\\"nofollow\\">@$2<\\/a>\', $output);\\nreturn $output;","locked":0,"properties":"a:0:{}","moduleguid":"","static":0,"static_file":"","content":"\\/**\\n * TwitterXFormat\\n *\\n * This snippet simply formats and links twitter feed statuses.\\n *\\n * TwitterX is free software; you can redistribute it and\\/or modify it\\n * under the terms of the GNU General Public License as published by the Free\\n * Software Foundation; either version 2 of the License, or (at your option) any\\n * later version.\\n *\\n * TwitterX is distributed in the hope that it will be useful, but WITHOUT ANY\\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\\n * A PARTICULAR PURPOSE. See the GNU General Public License for more details.\\n\\n * @author Stewart Orr @ Qodo Ltd <stewart@qodo.co.uk>\\n * @version 1.3.6\\n * @copyright Copyright 2012 by Qodo Ltd\\n * With thanks to Dameon87 https:\\/\\/github.com\\/Dameon87\\n *\\/\\n\\n$output = preg_replace(\'\\/(https?:\\\\\\/\\\\\\/[^\\\\s\\"<>]+)\\/\',\'<a href=\\"$1\\" target=\\"_blank\\" rel=\\"nofollow\\">$1<\\/a>\', $input);\\n$output = preg_replace(\'\\/(^|[\\\\n\\\\s])#([^\\\\s\\"\\\\t\\\\n\\\\r<:]*)\\/is\', \'$1<a href=\\"https:\\/\\/twitter.com\\/search?q=%23$2\\" target=\\"_blank\\" rel=\\"nofollow\\">#$2<\\/a>\', $output);\\n$output = preg_replace(\'\\/(^|[\\\\n\\\\s])@([^\\\\s\\"\\\\t\\\\n\\\\r<:]*)\\/is\', \'$1<a href=\\"https:\\/\\/twitter.com\\/$2\\" target=\\"_blank\\" rel=\\"nofollow\\">@$2<\\/a>\', $output);\\nreturn $output;"}',
        'guid' => '5f8a0abe4b1907bcf8449e3f2f0eddd9',
        'native_key' => 53,
        'signature' => '6d4a17f546d0ae7983e1ae4e7275a483',
      ),
    ),
  ),
  'related_object_attributes' => 
  array (
    'Chunks' => 
    array (
      'preserve_keys' => false,
      'update_object' => true,
      'unique_key' => 'name',
    ),
    'TemplateVars' => 
    array (
      'preserve_keys' => false,
      'update_object' => true,
      'unique_key' => 'name',
    ),
    'Templates' => 
    array (
      'preserve_keys' => false,
      'update_object' => true,
      'unique_key' => 'templatename',
    ),
    'Snippets' => 
    array (
      'preserve_keys' => false,
      'update_object' => true,
      'unique_key' => 'name',
    ),
  ),
  'namespace' => 'twitterx',
  'resolve' => 
  array (
    0 => 
    array (
      'type' => 'file',
      'body' => '{"source":"twitterx-1.3.6-pl\\/modCategory\\/c44cf2696de37e376fefa84e27b0bff2\\/0\\/","target":"return MODX_CORE_PATH . \'components\\/\';","name":"twitterx"}',
    ),
  ),
  'validate' => NULL,
  'vehicle_package' => 'transport',
  'vehicle_class' => 'xPDOObjectVehicle',
  'guid' => 'eb33ae08dc8a13f13e8aa840855f1ee2',
  'package' => 'modx',
  'class' => 'modCategory',
  'signature' => 'c44cf2696de37e376fefa84e27b0bff2',
  'native_key' => 1,
  'object' => '{"id":1,"parent":0,"category":"TwitterX"}',
);